<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">



<title type="text">PYNQer</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="https://devbisme.github.io/pynqer/docs/_site/feed.xml" />
<link rel="alternate" type="text/html" href="https://devbisme.github.io/pynqer/docs/_site/" />
<updated>2021-06-29T10:42:18-04:00</updated>
<id>https://devbisme.github.io/pynqer/docs/_site/</id>
<author>
  <name>Dave Vandenbout</name>
  <uri>https://devbisme.github.io/pynqer/docs/_site/</uri>
  <email>pynqer@xess.com</email>
</author>


<entry>
  <title type="html"><![CDATA[Introductory Interrupts]]></title>
  <link rel="alternate" type="text/html" href="https://devbisme.github.io/pynqer/docs/_site/blog/introductory-interrupts"/>
  <id>https://devbisme.github.io/pynqer/docs/_site/blog/introductory_interrupts</id>
  <published>2017-05-23T10:31:28-04:00</published>
  <updated>2017-05-23T10:31:28-04:00</updated>
  <author>
    <name>Dave Vandenbout</name>
    <uri>https://devbisme.github.io/pynqer/docs/_site</uri>
    <email>pynqer@xess.com</email>
  </author>
  
  <content type="html">
  
    &lt;h1 id=&quot;introductory-interrupts&quot;&gt;Introductory Interrupts&lt;/h1&gt;

&lt;p&gt;My &lt;a href=&quot;https://xesscorp.github.io/pynqer/docs/_site/blog/ripping-the-lid-off&quot;&gt;previous blog post&lt;/a&gt;
showed how I used &lt;em&gt;polling&lt;/em&gt; to get the state of the PYNQ’s pushbuttons and display them on the LEDs.
That’s a great way to burn through CPU cycles.&lt;/p&gt;

&lt;p&gt;Anyone who’s programmed embedded microcontrollers knows &lt;em&gt;interrupts&lt;/em&gt; provide
a more efficient solution that only checks the buttons when they change state.
Xilinx provides
&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/Pynq-Z1/notebooks/examples/asyncio_buttons.ipynb&quot;&gt;this PYNQ demo&lt;/a&gt;
that couples the ZYNQ interrupt hardware with Python’s
&lt;a href=&quot;https://pymotw.com/3/asyncio/index.html&quot;&gt;asyncio&lt;/a&gt; features.&lt;/p&gt;

&lt;p&gt;Unfortunately, I’m not very familiar with &lt;code class=&quot;highlighter-rouge&quot;&gt;asyncio&lt;/code&gt;, and
&lt;a href=&quot;http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/&quot;&gt;this post&lt;/a&gt;
didn’t fill me with confidence.
But, eventually, I picked up enough to understand the basic concepts of an
explicit &lt;em&gt;event loop&lt;/em&gt; that runs a set of &lt;em&gt;coroutines&lt;/em&gt; encapsulated in &lt;em&gt;tasks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Then I got confused again because I couldn’t see where the Xilinx example
started the event loop.
It turns out that’s hidden in the &lt;code class=&quot;highlighter-rouge&quot;&gt;wait_for_value()&lt;/code&gt; method of the
&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/switch.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; object&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wait_for_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Abort if the interrupt hardware isn't present in this overlay.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;RuntimeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Interrupts not available in this Overlay'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Get the default event loop.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_event_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;# Encapsulate the wait_for_value_async() coroutine in a task and run it
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# in the event loop until this button has the desired value.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_until_complete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ensure_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_value_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now if I just call &lt;code class=&quot;highlighter-rouge&quot;&gt;switch[0].wait_for_value(1)&lt;/code&gt;, the event loop in the following cell will run
until I flip the switch:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[1]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq.board&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Make sure the base overlay is installed in the ZYNQ PL.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'base.bit'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sw0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# Create Switch object for SW0.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Push SW0 up to terminate this cell.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SW0 is 1!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[1]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;SW0 is 1!&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;How is this any different than just polling?
The answer lies in the &lt;code class=&quot;highlighter-rouge&quot;&gt;wait_for_value_async()&lt;/code&gt; coroutine.
It contains a loop, but it’s a loop that only runs whenever the interrupt circuitry detects a change
in the switch state:&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Make the following function into a coroutine that runs in an event loop.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wait_for_value_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Abort if the overlay has no interrupt circuitry (see the next method).
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;RuntimeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Interrupts not available in this Overlay'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
    &lt;span class=&quot;c1&quot;&gt;# Only exit this loop when this switch has the desired value.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;# Pause this coroutine until one of the switches changes state and causes an interrupt.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;# If one of the switches caused the interrupt, then reset the interrupt flag.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00000001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The interrupt hardware is setup in the &lt;code class=&quot;highlighter-rouge&quot;&gt;__init__()&lt;/code&gt; method of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; object:&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Create the MMIO object that has register addresses for reading the switch state.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MMIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SEG_swsleds_gpio_Reg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# The index for this switch (either 0 or 1 for the PYNQ).
&lt;/span&gt;    
    &lt;span class=&quot;c1&quot;&gt;# Setup the interrupt hardware.
&lt;/span&gt;    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# No interrupts by default.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# Create the interrupt object using info from the overlay.
&lt;/span&gt;        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'swsleds_gpio/ip2intc_irpt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;# Enable the interrupts using register addresses in the switch MMIO.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x11C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00000001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ValueError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are a few mysteries in the code shown above, such as where the addresses
for querying and clearing the switch interrupts come from.
(I suspect that will be answered by diving into the HDL code for the &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; overlay.)
Also, I haven’t looked into the operations of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Interrupt&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;But I’ve seen enough to replicate handling the switch interrupts.
The following code creates tasks that scan the switches whenever
an interrupt happens.
A separate task runs for a set time interval after which
the scanning stops and the CPU utilization over that interval is displayed.
(Note that in this code I’ve used the new &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; keywords
in place of &lt;code class=&quot;highlighter-rouge&quot;&gt;asyncio.coroutine&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt;, respectively.)
So just run the following cell and see what happens.&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[2]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;asyncio&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;psutil&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_percent&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq.board&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Make sure the base overlay is installed in the ZYNQ PL.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'base.bit'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Create objects for both slide switches.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Coroutine that waits for a switch to change state.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# Wait for the switch to change and then print its state.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Wait for the interrupt to happen.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Switch[{num}] = {val}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# Clear the interrupt.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00000001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Create a task for each switch using the coroutine and place them on the event loop.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ensure_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;switches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;# Create a simple coroutine that just waits for a time interval to expire.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;just_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Run the event loop until the time interval expires,
# printing the switch values as they change.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_interval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# time in seconds
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_event_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wait_task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ensure_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;just_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Surround the event loop with functions to record CPU utilization.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu_percent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;percpu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Initialize the CPU monitoring.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_until_complete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cpu_used&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_percent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;percpu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Print the CPU utilization % for the interval.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'CPU Utilization = {cpu_used}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Remove all the tasks from the event loop.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[2]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Switch[0] = 1
Switch[1] = 0
Switch[0] = 1
Switch[1] = 0
Switch[0] = 0
Switch[1] = 0
Switch[0] = 0
Switch[1] = 0
Switch[0] = 0
Switch[1] = 1
Switch[0] = 0
Switch[1] = 1
Switch[0] = 0
Switch[1] = 0
Switch[0] = 0
Switch[1] = 1
Switch[0] = 0
Switch[1] = 1
Switch[0] = 0
Switch[1] = 0
Switch[0] = 0
Switch[1] = 0
CPU Utilization = [0.8, 0.3]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;While the code was running, I flipped each switch once.
For some reason, each transition of a switch caused the interrupt to be serviced twice.
(I still haven’t figured that out.)&lt;/p&gt;

&lt;p&gt;At the end of the prescribed time interval, the utilization of each CPU is shown to
be less than 1%.
To compare this with the use of polling, I wrote the following code that scans each switch continuously:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[3]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scan_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sw_val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Get the switch state.
&lt;/span&gt;        
        &lt;span class=&quot;c1&quot;&gt;# Print the switch state if it has changed.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Switch[{num}] = {val}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;AttributeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# An exception occurs the 1st time thru because the switch state
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# hasn't yet been stored in the object as an attribute.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;# Save the current state of the switch inside the switch object.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw_val&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Compute the end time for the polling.
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;cpu_percent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;percpu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Initialize the CPU monitoring.
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Now poll the switches for the given time interval.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;switches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scan_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
&lt;span class=&quot;c1&quot;&gt;# Print the CPU utilization during the polling.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu_used&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_percent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;percpu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'CPU Utilization = {cpu_used}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[3]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Switch[0] = 1
Switch[0] = 0
Switch[1] = 1
Switch[1] = 0
CPU Utilization = [0.5, 99.8]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Once again, I flipped each switch while the code was running.
Only now the utilization is near 100% for one of the CPUs, showing the 
interrupt-based code is much more efficient than polling.&lt;/p&gt;

&lt;h2 id=&quot;pertinent-files&quot;&gt;Pertinent Files&lt;/h2&gt;

&lt;p&gt;Here is a list of the files I examined while making this blog post:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/switch.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;switch.py&lt;/code&gt;&lt;/a&gt;: 
Defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; class for reading the state of the slide switches and handling their interrupts.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xesscorp/pynqer/tree/master/Notebooks/introductory_interrupts.ipynb&quot;&gt;This Jupyter notebook&lt;/a&gt;:
Contains the executable notebook from which this post was generated.&lt;/li&gt;
&lt;/ul&gt;

  
  &lt;p&gt;&lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site/blog/introductory-interrupts&quot;&gt;Introductory Interrupts&lt;/a&gt; was originally published by Dave Vandenbout at &lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site&quot;&gt;PYNQer&lt;/a&gt; on May 23, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Ripping the Lid Off]]></title>
  <link rel="alternate" type="text/html" href="https://devbisme.github.io/pynqer/docs/_site/blog/ripping-the-lid-off"/>
  <id>https://devbisme.github.io/pynqer/docs/_site/blog/ripping_the_lid_off</id>
  <published>2017-05-14T18:08:27-04:00</published>
  <updated>2017-05-14T18:08:27-04:00</updated>
  <author>
    <name>Dave Vandenbout</name>
    <uri>https://devbisme.github.io/pynqer/docs/_site</uri>
    <email>pynqer@xess.com</email>
  </author>
  
  <content type="html">
  
    &lt;p&gt;The obvious place to start exploring PYNQ is to play with its buttons and LEDs.
There’s already a &lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/Pynq-Z1/notebooks/examples/board_btns_leds.ipynb&quot;&gt;notebook&lt;/a&gt;
for that so there’s no need for me to replicate it.
A more interesting question is what’s going on underneath?
So I’m going to rip the lid off the PYNQ software and start examining its innards.&lt;/p&gt;

&lt;p&gt;A good starting point is the &lt;code class=&quot;highlighter-rouge&quot;&gt;pynq&lt;/code&gt; package:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[1]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;You can find the source here:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[2]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;pynq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__path__&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[2]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;['/opt/python3.6/lib/python3.6/site-packages/pynq']&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Overlay&lt;/code&gt; class in the &lt;code class=&quot;highlighter-rouge&quot;&gt;pynq&lt;/code&gt; package lets you specify a particular overlay that will be loaded into the Programmable Logic (PL) section of the ZYNQ chip.
Xilinx has already provided a pre-compiled overlay that interfaces to the PYNQ’s buttons and LEDs (and other things):&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[3]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pynq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'base.bit'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;This reads in the bitstream for the overlay, but doesn’t yet load it into the PL.
Let’s see what’s in it:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[4]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[4]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 '_bitfile_name',
 '_gpio_dict',
 '_host',
 '_interrupt_controllers',
 '_interrupt_pins',
 '_ip_dict',
 '_remote',
 '_server',
 '_timestamp',
 'bitfile_name',
 'bitstream',
 'client_request',
 'download',
 'gpio_dict',
 'interrupt_controllers',
 'interrupt_pins',
 'ip_dict',
 'is_loaded',
 'load_ip_data',
 'reset',
 'server_update',
 'setup']&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;From this, the actual location of the overlay bitstream is easily found:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[5]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitfile_name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[5]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;'/opt/python3.6/lib/python3.6/site-packages/pynq/bitstream/base.bit'&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;If you look in that directory, you’ll also see a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;base.tcl&lt;/code&gt;.
This contains &lt;em&gt;a lot&lt;/em&gt; of information about the interface between the 
PL and the Processing System (PS) where the PYNQ Python code runs.
One of the things the &lt;code class=&quot;highlighter-rouge&quot;&gt;Overlay&lt;/code&gt; class does is search through this
file, looking up all the interface information, and loading the
necessary bits into dictionaries in the object it creates.&lt;/p&gt;

&lt;p&gt;You would &lt;em&gt;think&lt;/em&gt; the &lt;code class=&quot;highlighter-rouge&quot;&gt;gpio_dict&lt;/code&gt; contains the information about accessing
the LEDs and buttons on the PYNQ board. Let’s see:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[6]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_dict&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[6]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{'audio_path_sel': [3, None],
 'mb_1_intr_ack': [4, None],
 'mb_1_reset': [0, None],
 'mb_2_intr_ack': [5, None],
 'mb_2_reset': [1, None],
 'mb_3_intr_ack': [6, None],
 'mb_3_reset': [2, None]}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Hmm, not quite what was expected.
Looks like the reset and interrupt acknowledge pins are here, but nothing else.
So the buttons and LEDs don’t have direct connections from the PL to the PS.
Let’s try &lt;code class=&quot;highlighter-rouge&quot;&gt;ip_dict&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[7]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_dict&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[7]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{'SEG_axi_dma_0_Reg': [2151677952, 65536, None],
 'SEG_axi_dma_0_Reg1': [2151743488, 65536, None],
 'SEG_axi_dynclk_0_reg0': [1136721920, 65536, None],
 'SEG_axi_gpio_video_Reg': [1092747264, 65536, None],
 'SEG_axi_vdma_0_Reg': [1124073472, 65536, None],
 'SEG_btns_gpio_Reg': [1092681728, 65536, None],
 'SEG_d_axi_pdm_1_S_AXI_reg': [1136656384, 65536, None],
 'SEG_hdmi_out_hpd_video_Reg': [1092812800, 65536, None],
 'SEG_mb_bram_ctrl_1_Mem0': [1073741824, 65536, None],
 'SEG_mb_bram_ctrl_2_Mem0': [1107296256, 65536, None],
 'SEG_mb_bram_ctrl_3_Mem0': [1140850688, 65536, None],
 'SEG_rgbled_gpio_Reg': [1092878336, 65536, None],
 'SEG_swsleds_gpio_Reg': [1092616192, 65536, None],
 'SEG_system_interrupts_Reg': [1098907648, 65536, None],
 'SEG_trace_cntrl_0_Reg': [2210398208, 65536, None],
 'SEG_trace_cntrl_0_Reg2': [2210463744, 65536, None],
 'SEG_v_tc_0_Reg': [1136787456, 65536, None],
 'SEG_v_tc_1_Reg': [1136852992, 65536, None]}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;This is more helpful. There are entries that look related to the buttons (&lt;code class=&quot;highlighter-rouge&quot;&gt;SEG_btns_gpio_Reg&lt;/code&gt;), 
LEDs (&lt;code class=&quot;highlighter-rouge&quot;&gt;SEG_swsleds_gpio_Reg&lt;/code&gt;), and RGB LEDs (&lt;code class=&quot;highlighter-rouge&quot;&gt;SEG_rgbled_gpio_Reg&lt;/code&gt;).
But what do the entries mean?&lt;/p&gt;

&lt;p&gt;Typing:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;help(base)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;provides some information about that (along with quite a bit of other stuff):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Each entry of the IP dictionary is a mapping:
 |  'name' -&amp;gt; [address, range, state]
 |  
 |  where
 |  name (str) is the key of the entry.
 |  address (int) is the base address of the IP.
 |  range (int) is the address range of the IP.
 |  state (str) is the state information about the IP.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This implies that reading the buttons or driving the LEDs is done using a read or write
to a location within a bank of memory addresses.
So the Python code for the buttons and LEDs must contain the instructions for what
particular address offsets and bit locations are used.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/button.py&quot;&gt;Python code for the buttons&lt;/a&gt; is stored in:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[8]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq.board.button&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pynq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;board&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__file__&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt output-prompt&quot;&gt;
	
		Out
        
	[8]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;'/opt/python3.6/lib/python3.6/site-packages/pynq/board/button.py'&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;There are two important imports in there:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from pynq import MMIO
from pynq import PL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;MMIO&lt;/code&gt; class instantiates objects for reading and writing to a segment of memory, and
the &lt;code class=&quot;highlighter-rouge&quot;&gt;PL&lt;/code&gt; is a singleton object that provides access to the dictionaries of whatever overlay is currently
loaded into the PL of the ZYNQ.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;__init__&lt;/code&gt; method of a &lt;code class=&quot;highlighter-rouge&quot;&gt;Button&lt;/code&gt; object uses
the &lt;code class=&quot;highlighter-rouge&quot;&gt;ip_dict&lt;/code&gt; of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Overlay&lt;/code&gt; object to initialize an &lt;code class=&quot;highlighter-rouge&quot;&gt;MMIO&lt;/code&gt; object with the starting
address and size of the address range for the buttons:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def __init__(self, index):
        if Button._mmio is None:
            Button._mmio = MMIO(PL.ip_dict[&quot;SEG_btns_gpio_Reg&quot;][0], 512)
        self.index = index  # This is the bit position of a button in the memory word.
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then the &lt;code class=&quot;highlighter-rouge&quot;&gt;Button&lt;/code&gt; object’s &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; method will return a
particular button’s current state by reading the memory word and masking-off the associated bit:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def read(self):
    curr_val = Button._mmio.read()  # Read the 1st word of the memory range.
    return (curr_val &amp;amp; (1 &amp;lt;&amp;lt; self.index)) &amp;gt;&amp;gt; self.index  # Mask off the bit for this button.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/led.py&quot;&gt;Python code for the LED&lt;/a&gt;
is very similar except that it writes a bit to the memory address to turn an LED on or off.
(Except that the address for writing the LED values is offset by &lt;code class=&quot;highlighter-rouge&quot;&gt;0x8&lt;/code&gt; for some unknown reason
that may become apparent later.)&lt;/p&gt;

&lt;p&gt;So, if I understand this correctly, I should be able to explicitly use &lt;code class=&quot;highlighter-rouge&quot;&gt;MMIO&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;PL&lt;/code&gt; to write my own
code for reading the state of a buttons and turning the LEDs on or off.
The code in the following cell can be run and then (for a 10-second interval)
the LED above each button on the PYNQ-Z1 will come on as long as that button is pushed.&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[9]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MMIO&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'base.bit'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;# Load the PL of the ZYNQ with the bitstream for buttons &amp;amp; LEDs.
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Create MMIO objects for reading the buttons and turning the LEDs on and off.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button_addr&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SEG_btns_gpio_Reg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;button_range&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SEG_btns_gpio_Reg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;button_mmio&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MMIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button_range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;led_addr&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SEG_swsleds_gpio_Reg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;led_range&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'SEG_swsleds_gpio_Reg'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;led_mmio&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MMIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;led_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;led_range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# For a ten-second interval, read the values of all four buttons and
# display it on all four of the LEDs.
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buttons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;button_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# Read memory word containing all four button values.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;led_mmio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buttons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# Write button values to memory word driving all four LEDs.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;The same thing can be done using the higher-level PYNQ software:&lt;/p&gt;

&lt;div class=&quot;cell&quot;&gt;
	&lt;div class=&quot;prompt input-prompt&quot;&gt;
	
		In
        
	[10]:&lt;/div&gt;
	
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Overlay&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq.board.button&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Button&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pynq.board.led&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LED&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Create lists of the buttons and LEDs.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buttons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;leds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# For a ten-second interval, execute a loop to read the values of each button and
# display it on the associated LED.
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;leds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buttons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;/div&gt;

&lt;p&gt;Obviously, using the higher-level constructs makes the intent of the code clearer, so
why bother with the low-level, explicit approach?
&lt;em&gt;Because it shows how the magic is done!&lt;/em&gt;
And I’ll need to recreate that magic when I build my own PL overlays and interface them to the PS.
An understanding of the underlying code is necessary for that.&lt;/p&gt;

&lt;p&gt;You’ll notice in &lt;code class=&quot;highlighter-rouge&quot;&gt;button.py&lt;/code&gt; that it includes some code for handling interrupts.
I’ll start tinkering with those next.&lt;/p&gt;

&lt;h2 id=&quot;pertinent-files&quot;&gt;Pertinent Files&lt;/h2&gt;

&lt;p&gt;Here is a list of the files I examined while making this blog post:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/Pynq-Z1/bitstream/base.bit&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;base.bit&lt;/code&gt;&lt;/a&gt;: 
A bitstream that program the ZYNQ’s PL with a set of interfaces to the hardware on the PYNQ-Z1 board.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/Pynq-Z1/bitstream/base.tcl&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;base.tcl&lt;/code&gt;&lt;/a&gt;: 
Contains a set of definitions for register/memory addresses for the interfaces in the &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; overlay.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/pl.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pl.py&lt;/code&gt;&lt;/a&gt;: 
Defines the classes for PL overlays (&lt;code class=&quot;highlighter-rouge&quot;&gt;PL_Meta&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitstream&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Overlay&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/mmio.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mmio.py&lt;/code&gt;&lt;/a&gt;: 
Defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;MMIO&lt;/code&gt; class for reading/writing a segment of memory.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/button.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;button.py&lt;/code&gt;&lt;/a&gt;: 
Defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;Button&lt;/code&gt; class for reading the state of the pushbuttons on the PYNQ-Z1.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/switch.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;switch.py&lt;/code&gt;&lt;/a&gt;: 
Defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;Switch&lt;/code&gt; class for reading the state of the slide switches on the PYNQ-Z1.
(I didn’t use these in this post.)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/led.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;led.py&lt;/code&gt;&lt;/a&gt;: 
Defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;LED&lt;/code&gt; class for changing the state of ON-OFF LEDs on the PYNQ-Z1.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xilinx/PYNQ/blob/master/python/pynq/board/rgbled.py&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rgbled.py&lt;/code&gt;&lt;/a&gt;: 
Defines the &lt;code class=&quot;highlighter-rouge&quot;&gt;RGBLED&lt;/code&gt; class for changing the state of RGB LEDs on the PYNQ-Z1.
(I didn’t use these in this post.)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xesscorp/pynqer/tree/master/Notebooks/ripping_the_lid_off.ipynb&quot;&gt;This Jupyter notebook&lt;/a&gt;:
Contains the executable notebook from which this post was generated.&lt;/li&gt;
&lt;/ul&gt;


  
  &lt;p&gt;&lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site/blog/ripping-the-lid-off&quot;&gt;Ripping the Lid Off&lt;/a&gt; was originally published by Dave Vandenbout at &lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site&quot;&gt;PYNQer&lt;/a&gt; on May 14, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Reading the Docs]]></title>
  <link rel="alternate" type="text/html" href="https://devbisme.github.io/pynqer/docs/_site/blog/reading-the-docs"/>
  <id>https://devbisme.github.io/pynqer/docs/_site/blog/reading-the-docs</id>
  <published>2017-04-22T14:04:30-04:00</published>
  <updated>2017-04-22T14:04:30-04:00</updated>
  <author>
    <name>Dave Vandenbout</name>
    <uri>https://devbisme.github.io/pynqer/docs/_site</uri>
    <email>pynqer@xess.com</email>
  </author>
  
  <content type="html">
  
    &lt;p&gt;After &lt;a href=&quot;https://xesscorp.github.io/pynqer/docs/_site/blog/pynq-setup&quot;&gt;installing my PYNQ board&lt;/a&gt;,
I took a break to release an update to my
&lt;a href=&quot;https://xesscorp.github.io/skidl&quot;&gt;SKiDL circuit design language&lt;/a&gt;.
These things always take longer than you expect,
but I’m back now and my next task is to familiarize myself with the PYNQ
documentation.&lt;/p&gt;

&lt;p&gt;When you first login to the PYNQ, you’ll see the &lt;code class=&quot;highlighter-rouge&quot;&gt;getting_started&lt;/code&gt; link:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/reading-the-docs/welcome-screen.png&quot; width=&quot;800&quot; alt=&quot;Welcome screen.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on that (because that seems a natural place to start) brings up a set
of introductory Jupyter notebooks:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/reading-the-docs/getting-started-screen.png&quot; width=&quot;800&quot; alt=&quot;Getting Started notebooks.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first thing you need to realize about these notebooks is &lt;em&gt;you can skip all of them!&lt;/em&gt;
If you’re like me and have to read everything out of fear you’ll miss something,
know that all this material is already available at the 
&lt;a href=&quot;https://pynq.readthedocs.io/en/latest/&quot;&gt;main PYNQ documentation site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, one advantage of having these notebooks immediately available upon setting
up the PYNQ is that you can exercise the board without having to download anything.
Here’s what the notebooks cover:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1_jupyer_notebook.ipynb&lt;/code&gt;: Explains the basics of getting around in a Jupyter
notebook.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2_programming_python.ipynb&lt;/code&gt;: Gives a &lt;em&gt;brief&lt;/em&gt; introduction to Python, but you’ll
want to take advantage of the many online Python tutorials to get a full
understanding. (This is probably a good idea, just like learning &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; was a good
idea in the 80’s.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3_programming_onboard.ipynb&lt;/code&gt;: Let’s you play with the buttons, slide switches
and LEDs of the PYNQ. Every system has a blinky, and this one is PYNQ’s.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4_base_overlay_iop.ipynb&lt;/code&gt;: Shows you how to access the Pmod ports to sense the
ambient light level and display it on an OLED. Of course, if you don’t have
the light sensor or OLED PMODs then this is pretty much useless.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5_base_overlay_video.ipynb&lt;/code&gt;: Demonstrates capturing and displaying video via
the two HDMI ports on the PYNQ. There’s also a bit of image processing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6_base_overlay_audio.ipynb&lt;/code&gt;: Like the video demo, but using the on-board
microphone (it’s actually a tiny chip on the underside of the board) and an
external speaker or headphones to record and playback sound.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Turning to the &lt;a href=&quot;https://pynq.readthedocs.io/en/latest/&quot;&gt;main PYNQ site&lt;/a&gt;, 
here are the nuggets I extracted:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;PYNQ uses the ZYNQ chips’s processing system (PS) with dual ARM processors
to run the Jupyter notebook and Python interpreter.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The programmable logic (PL) section is used to host &lt;em&gt;overlays&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An overlay programs the PL to provide support for an application.
An API allows the PS to load overlays into the PL and access functions in it 
such as read and write registers.
The API is contained in a Python module and accessed with Python.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating an overlay is done using the Vivado FPGA programming environment and
requires logic design expertise.
To leverage this limited expertise, an overlay is typically designed with
maximum generality so it can be used in a large number of applications.
For example, the &lt;em&gt;base overlay&lt;/em&gt; provides functions for working with the Pmod
and Arduino I/O interfaces, audio I/O, HDMI I/O, and general-purpose I/O.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The Arduino and Pmod connectors can interface to a wide variety of external
circuitry. In order to support this without having to redesign the logic circuitry
for each application, the base overlay uses reprogrammable I/O Processors (IOPs),
a set of peripherals (timers, SPI, I$^2$C, interrupt controllers),
and a reconfigurable switch.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The IOP is programmed in C/C++ and is intended for real-time, low-level
operations. The PS is programmed with Python for higher-level, data-handling
and display operations.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The base overlay uses a 32-bit, 100 MHz Microblaze for each IOP.
A 64 KB dual-port BRAM stores the program for the Microblaze.
The PS loads the program into the BRAM and starts the Microblaze.
The remainder of the BRAM can be used for local data or for passing data
back-and-forth between the PS and the IOP.
A &lt;em&gt;mailbox&lt;/em&gt; located between &lt;code class=&quot;highlighter-rouge&quot;&gt;0xF000&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF&lt;/code&gt; in the IOP BRAM is typically
used for passing data. 
The IOP also has access to the external DDR chip on the PYNQ board, and
this can be used to transfer larger blocks of data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The reconfigurable switch in the IOP allows it to connect its various peripherals
to the physical I/O pins of the Pmod or Arduino headers.
The switch is controlled by the Microblaze.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Programs for the IOP are developed using the
&lt;a href=&quot;http://www.xilinx.com/products/design-tools/embedded-software/sdk.html&quot;&gt;Xilinx SDK&lt;/a&gt;.
&lt;a href=&quot;http://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2016-1.html&quot;&gt;Version 2016.1 of Vivado and the SDK&lt;/a&gt; is recommended.
(I’m currently using 2016.4, so I’ll continue with that until a problem arises.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://pynq.readthedocs.io/en/latest/11b_iop_applications.html#compiling-projects&quot;&gt;Building an application for an IOP&lt;/a&gt;
requires:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;A &lt;em&gt;hardware description file&lt;/em&gt; (HDF) that Vivado uses to create a &lt;em&gt;Hardware Platform&lt;/em&gt;.
(Already provided for the PYNQ.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;A &lt;em&gt;board support package&lt;/em&gt; (BSP) that contains the software for interacting with
the peripherals described in the HDF. There can be more than one BSP for a
hardware platform. For example, the base overlay has two BSPs: one for the
Pmod IOP and another for the Arduino IOP.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The BSP is linked with the application C/C++ code by the SDK compiler to create
an &lt;code class=&quot;highlighter-rouge&quot;&gt;.elf&lt;/code&gt; file which is then translated into a &lt;code class=&quot;highlighter-rouge&quot;&gt;.bin&lt;/code&gt; file that can
be loaded into the IOP program memory.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The IOP has an API for interfacing to its peripherals, its
reconfigurable switch, and the IOP-to-PS mailbox.
(The PS has a separate API for communicating with the IOP.)
The Arduino and Pmod IOPs are identical except for the reconfigurable switches
that connect their peripherals to the I/O pins of the
&lt;a href=&quot;https://github.com/Xilinx/PYNQ/tree/master/Pynq-Z1/vivado/ip/arduino_io_switch_1.0/drivers/arduino_io_switch_v1_0/src&quot;&gt;Arduino&lt;/a&gt;
or
&lt;a href=&quot;https://github.com/Xilinx/PYNQ/tree/master/Pynq-Z1/vivado/ip/pmod_io_switch_1.0/drivers/pmod_io_switch_v1_0/src&quot;&gt;Pmod&lt;/a&gt;
headers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The details of programming the IOP are explained &lt;a href=&quot;https://pynq.readthedocs.io/en/latest/11c_iop_using_peripherals.html&quot;&gt;here&lt;/a&gt;.
This covers the details of using the IOP &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; API to talk to the peripherals
and reconfigurable switch, and also covers the C and Python APIs for mailbox
communications.
(I won’t summarize this further. The link will provide a path to the details
needed to do IOP programming.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Interrupt architecture:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The IOPs use the Microblaze
&lt;a href=&quot;https://www.xilinx.com/products/intellectual-property/axi_intc.html&quot;&gt;AXI Interrupt Controller&lt;/a&gt;
internally.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The  base overlay also has an interrupt controller that can throw interrupts
from the IOPs over to the PS.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;One way the interrupts from the IOPs are handled in the PS is with Python’s
&lt;a href=&quot;https://docs.python.org/3.6/library/asyncio.html#module-asyncio&quot;&gt;asyncio package&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Creating Overlays:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Unlike a standard Zynq design, PYNQ’s PS section is already defined and the
PL design must match its settings (e.g., clock configuration).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Vivado exports a &lt;code class=&quot;highlighter-rouge&quot;&gt;tcl&lt;/code&gt; file describing the application mapped into the PL.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;tcl&lt;/code&gt; file is parsed by the PS using the &lt;code class=&quot;highlighter-rouge&quot;&gt;Overlay&lt;/code&gt; class of the &lt;code class=&quot;highlighter-rouge&quot;&gt;pynq&lt;/code&gt; Python
package.
The result of the parsing is a list of addressable resources in the overlay
such as interrupt controllers, GPIO pins, IOP BRAMs, etc.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;pynq&lt;/code&gt; package provides the &lt;code class=&quot;highlighter-rouge&quot;&gt;MMIO&lt;/code&gt; class which is used to do memory-to-memory
transfers between the PS and the addressable elements of an overlay.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After reviewing the PYNQ docs, I see three levels for using the PYNQ, each level
requiring the skills of the ones above it:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You can be given an overlay and then control it from Python as if it were a
peripheral attached to the PS. This requires understanding of the &lt;code class=&quot;highlighter-rouge&quot;&gt;pynq&lt;/code&gt;
Python package.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You can be given an overlay but run your own programs on any 
IOPs it contains. This requires additional skills to:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;develop programs for the IOPs (Microblaze programming with the SDK or otherwise),&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;create an API in Python for talking to the IOPs from the PS, and&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;package, download and initiate the compiled programs to the IOPs.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Develop your own overlay for the PL using Vivado.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So my job now is to progress through these levels.&lt;/p&gt;

  
  &lt;p&gt;&lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site/blog/reading-the-docs&quot;&gt;Reading the Docs&lt;/a&gt; was originally published by Dave Vandenbout at &lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site&quot;&gt;PYNQer&lt;/a&gt; on April 22, 2017.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[PYNQ Setup]]></title>
  <link rel="alternate" type="text/html" href="https://devbisme.github.io/pynqer/docs/_site/blog/pynq-setup"/>
  <id>https://devbisme.github.io/pynqer/docs/_site/blog/pynq-setup</id>
  <published>2017-04-04T12:25:39-04:00</published>
  <updated>2017-04-04T12:25:39-04:00</updated>
  <author>
    <name>Dave Vandenbout</name>
    <uri>https://devbisme.github.io/pynqer/docs/_site</uri>
    <email>pynqer@xess.com</email>
  </author>
  
  <content type="html">
  
    &lt;p&gt;Every blog like this starts off with a post about setting up the equipment.
This is that post.
Basically, I’m following the instructions given
&lt;a href=&quot;https://pynq.readthedocs.io/en/latest/1_getting_started.html&quot;&gt;here&lt;/a&gt;.
I won’t be saying anything new unless I manage to screw up.&lt;/p&gt;

&lt;p&gt;Every blog post has to have at least one picture, so here’s one
of the PYNQ-Z1 board I received from Patrick Lysaght of Xilinx.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/PYNQ.jpg&quot; width=&quot;800&quot; alt=&quot;A PYNQ board.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Along with the board, I got a bunch of cables and an 8GB μSD card.
It probably contained a preloaded image with the OS and example files
but I didn’t even check.
I just downloaded the &lt;a href=&quot;https://files.digilent.com/Products/PYNQ/pynq_z1_image_2017_02_10.zip&quot;&gt;freshest image&lt;/a&gt;
and reflashed the card using &lt;a href=&quot;https://sourceforge.net/projects/win32diskimager/&quot;&gt;Win32 Disk Imager&lt;/a&gt;.
(Bonus points if you can see what I did wrong here.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/reflash-card-wrong.png&quot; alt=&quot;Reflashing the PYNQ image.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I inserted the programmed μSD card into the PYNQ and set the &lt;code class=&quot;highlighter-rouge&quot;&gt;JP4&lt;/code&gt; jumper to
the &lt;code class=&quot;highlighter-rouge&quot;&gt;SD&lt;/code&gt; setting so the board would boot from it.&lt;/p&gt;

&lt;p&gt;Next, I connected an Ethernet cable directly from the PYNQ to my PC and 
&lt;a href=&quot;http://helpdeskgeek.com/windows-7/bridge-network-connections-in-windows-7/&quot;&gt;bridged the PC Ethernet adapter to the wireless adapter&lt;/a&gt;
that accesses the internet.&lt;/p&gt;

&lt;p&gt;Then I attached a micro-USB cable from my PC to the &lt;code class=&quot;highlighter-rouge&quot;&gt;PROG UART&lt;/code&gt; connector
on the PYNQ.&lt;/p&gt;

&lt;p&gt;Last but not least, I attached the supplied 12V / 3.0A power adapter
to the power jack on the PYNQ, set the shunt on the &lt;code class=&quot;highlighter-rouge&quot;&gt;JP5&lt;/code&gt; jumper to the &lt;code class=&quot;highlighter-rouge&quot;&gt;REG&lt;/code&gt;
position (the upper two pins), &lt;strong&gt;made sure the power switch was in the OFF position&lt;/strong&gt;,
and plugged the adapter into a wall socket.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/pynq-connections.jpg&quot; width=&quot;800&quot; alt=&quot;Connections to the PYNQ.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The moment of truth had arrived: I pushed the power switch to the right and … nothing.
The red power LED came on, but the green &lt;code class=&quot;highlighter-rouge&quot;&gt;DONE&lt;/code&gt; LED (&lt;code class=&quot;highlighter-rouge&quot;&gt;LED12&lt;/code&gt;) midway between the
ZYNQ chip and the Ethernet connector stubbornly stayed off.
That indicated the ZYNQ was not getting configured.
Maybe reflashing that μSD card was a bad idea…&lt;/p&gt;

&lt;p&gt;It turned out it &lt;em&gt;was&lt;/em&gt; a bad idea.
After checking all the connections and powering the board on and off a few times,
I decided to check how I programmed the μSD card.
If you look at the Win32 Disk Imager screen above, you’ll see &lt;em&gt;I programmed
the card with the ZIP file instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;.img&lt;/code&gt; file it contained!&lt;/em&gt;
Doh!
Unpacking the ZIP file and re-reflashing the card with the &lt;code class=&quot;highlighter-rouge&quot;&gt;.img&lt;/code&gt; file fixed that error:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/reflash-card-right.png&quot; alt=&quot;Re-reflashing the PYNQ image.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After replacing the corrected μSD card in the PYNQ and applying power, the &lt;code class=&quot;highlighter-rouge&quot;&gt;DONE&lt;/code&gt; LED
comes on and (after a small delay) the &lt;code class=&quot;highlighter-rouge&quot;&gt;LD0 - LD5&lt;/code&gt; LEDs flash on-and-off eight or nine times.
That means the ZYNQ has configured correctly, booted the OS, and established communications
so it’s ready to talk to me.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/pynq-ready.png&quot; width=&quot;800&quot; alt=&quot;LED pattern for properly initialized PYNQ.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Or maybe not:
when I tried to communicate with the board using a browser and either
&lt;code class=&quot;highlighter-rouge&quot;&gt;http://pynq:9090&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.2.99:9090&lt;/code&gt; as the address, I got
the dreaded message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/unreachable-pynq.png&quot; width=&quot;800&quot; alt=&quot;The PYNQ was unreachable through the browser.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I tried a bunch of variations on the addresses and nothing worked.
Eventually it occurred to me that, since I was using a direct connection to the
board without an intervening router running DHCP, I needed to adjust the IP address of
my PC’s Ethernet port to match the PYNQ’s subnet (192.168.2):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/setting-ethernet-IPV4.png&quot; alt=&quot;Setting the PC Ethernet port IPV4 address to match the PYNQ.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But even that didn’t fix the problem.
Finally, I removed the bridge between the PC’s Ethernet port and its wireless adapter.
With that, I was able to login using the hard-coded IPV4 address of the PYNQ:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/hard-coded-login.png&quot; alt=&quot;Logging into the PYNQ using its hard-coded IPV4 address.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, the PYNQ couldn’t reach the internet in this configuration,
and I wanted to be able to easily download new software to it.
I went back and tried Internet Connection Sharing (ICS) but it complained
it needed to occupy the 192.168.0.1 address and that’s where my wireless router sits.
Therefore, I moved the router to the 192.168.1.x subnet and ICS still couldn’t
get packets from the PYNQ to the internet and back.
So I ditched ICS and tried to go old school and modify the routing tables
on my PC and wireless router (without much success).
Then I moved my entire network to the 192.168.2.x subnet to match up with the
subnet used by the PYNQ.
That actually worked, but it seemed like a pretty janky setup that might cause
other problems down the road.&lt;/p&gt;

&lt;p&gt;Admitting defeat, I dug out an old travel WiFi router, configured it as a client-mode
device, and used it to connect the PYNQ to my wireless network.
Then all my devices could see it and the PYNQ could get onto the internet.
I could also remove the direct Ethernet connection and pack everything
into a small space with short cords I’d be less likely to snag:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/final-pynq-setup.png&quot; alt=&quot;PYNQ with WiFi connection, USB connection, and power adapter.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With this arrangement, the PYNQ is accessible from anywhere within reach of my WiFi and I
can download things like new Python modules for it from the internet:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://devbisme.github.io/pynqer/docs/_site/images/pynq-setup/pynq-downloading.png&quot; alt=&quot;PYNQ downloading a Python module.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now it’s on to the serious play of making the PYNQ do stuff.&lt;/p&gt;

  
  &lt;p&gt;&lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site/blog/pynq-setup&quot;&gt;PYNQ Setup&lt;/a&gt; was originally published by Dave Vandenbout at &lt;a href=&quot;https://devbisme.github.io/pynqer/docs/_site&quot;&gt;PYNQer&lt;/a&gt; on April 04, 2017.&lt;/p&gt;</content>
</entry>

</feed>
